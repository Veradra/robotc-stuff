#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotent,      sensorPotentiometer)
#pragma config(Sensor, in2,    lineRight,      sensorLineFollower)
#pragma config(Sensor, in3,    lineCenter,     sensorLineFollower)
#pragma config(Sensor, in4,    lineLeft,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  frontTouch,     sensorTouch)
#pragma config(Sensor, dgtl6,  bumpTouch,      sensorTouch)
#pragma config(Sensor, dgtl7,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl12, led,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  rightIME,       sensorNone)
#pragma config(Sensor, I2C_2,  leftIME,        sensorNone)
#pragma config(Sensor, I2C_3,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl3)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//int variables. Declare before use!//
int left = 36;
int right = 30;
int dist = 15;
int turn = 250;
int turnspeed = 70;
int sl = 600;
int sr = 605;
int leftc = 60;
int rightc = 60;
int avoid = 200;
int leftCorr = 100;
int rightCorr = 100;
int lc = 25;
int rc = 25;
int armspeed = 40;
int clawspeed = 40;
int sw;
int t = 2000;

//void functions. Declare before use!
//Automatically turns left
void goLeft()
{
	resetSensor(leftEncoder);
	resetSensor(rightEncoder);
	setMotor(leftMotor, turnspeed);
	setMotor(rightMotor, -turnspeed);
	waitUntil(SensorValue[rightEncoder] >= turn && SensorValue[leftEncoder] <= -turn);
	stopMultipleMotors(leftMotor, rightMotor);
	wait(20, milliseconds);
}
//Automatically turns right
void goRight()
{
	resetSensor(leftEncoder);
	resetSensor(rightEncoder);
	setMotor(leftMotor, -turnspeed);
	setMotor(rightMotor, turnspeed);
	waitUntil(SensorValue[rightEncoder] <= -turn && SensorValue[leftEncoder] >= turn);
	stopMultipleMotors(leftMotor, rightMotor);
	wait(20, milliseconds);
}
/*
Automatically goes forwards. !NOTE! this has a "switch" variable ('sw'). By
default, this value is set to 0 but can be changed by putting a number where X is
in 'goForward(X);' when needed. Please go 'sw = -1;' when done. This will be
cleared and set to 0 shortly after (the default), and stop the motors.
*/
void goForward(int sw, int encval)
{
	setMotor(leftMotor, left);
	setMotor(rightMotor, right);
	//If we set sw to 0, we go forwards until it is dist cm from an object.
	if(sw == 0)
	{
		waitUntil(SensorValue[sonarSensor] <= dist);
		stopMultipleMotors(leftMotor, rightMotor);
	}
	//If we set sw to 1, we set it to go forward for t milliseconds.
	if(sw == 1)
	{
		wait1Msec(t);
		stopMultipleMotors(leftMotor, rightMotor);
	}
	//If we set sw to 2, we just go forwards. You must do the programming to stop it.
	if(sw == 2)
	{
		setMotor(leftMotor, left);
		setMotor(rightMotor, right);
		wait(10, milliseconds);
	}
	if(sw == 3)
	{
		setMotor(leftMotor, left);
		setMotor(rightMotor, right);
		waitUntil(SensorValue[leftEncoder] >=encval && SensorValue[rightEncoder] >=encval);
	}
}
//Allows for manual left point turns.
void leftCTRL()
{
	setMotor(leftMotor, turnspeed);
	setMotor(rightMotor, -turnspeed);
	wait1Msec(20);
	if(vexRT[Btn7L] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}
//Allows for manual right point turns.
void rightCTRL()
{
	setMotor(leftMotor, -turnspeed);
	setMotor(rightMotor, turnspeed);
	wait1Msec(20);
	if(vexRT[Btn7R] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}
//Allows for manual forwards.
void forwardCTRL()
{
	setMotor(rightMotor, rightc);
	setMotor(leftMotor, leftc);
	wait1Msec(20);
	if(vexRT[Btn7U] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}
//Allows for manual backwards.
void backwardsCTRL()
{
	setMotor(rightMotor, -rightc);
	setMotor(leftMotor, -leftc);
	wait1Msec(20);
	if(vexRT[Btn7D] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}
//Automatic left swing turn.
void swingLeft(int multi)
{
	resetSensor(leftEncoder);
	resetSensor(rightEncoder);
	setMotor(leftMotor, 0);
	setMotor(rightMotor, turnspeed);
	waitUntil(SensorValue[leftEncoder] >= sl*multi);
	stopMultipleMotors(leftMotor, rightMotor);
	wait(20, milliseconds);
}
//Automatic right swing turn.
void swingRight(int multi)
{
	resetSensor(leftEncoder);
	resetSensor(rightEncoder);
	setMotor(leftMotor, turnspeed);
	setMotor(rightMotor, 0);
	waitUntil(SensorValue[rightEncoder] >= sr*multi);
	stopMultipleMotors(leftMotor, rightMotor);
	wait(20, milliseconds);
}
//Left line follower correction.
void correctionL()
{
	setMotor(leftMotor, -lc);
	setMotor(rightMotor, rightCorr);
	wait(10, milliseconds);
}
//Right line follower correction.
void correctionR()
{
	setMotor(leftMotor, leftCorr);
	setMotor(rightMotor, -rc);
	wait(10, milliseconds);
}
//Moves the arm out of the way automatically.
void afo()
{
	setMotor(armMotor, armspeed);
	waitUntil(SensorValue[armPotent] <= 1250);
	stopMotor(armMotor);
}
/*
Sonar task is here! This task will make sure you can toggle "crash mode"
aka, if you can run into a wall or not. Not much needs to be done with it.
*/

task sonar()
{
	while(true)
		if(SensorValue[sonarSensor] <= dist)
	{
		stopMultipleMotors(leftMotor, rightMotor);
		}else{
		wait1Msec(10);
	}
}

//Main task, has the bulk of the program in use.
task main()
{
	//We wait for the bumpTouch sensor to be pressed to start.
	waitUntil(SensorValue[bumpTouch] == 1 || vexRT[Ch4] == 127);
	{
		//Sets 'sw' to 0. Moves arm out of the way.
		sw = 0;
		afo();
		repeat(forever)
		{
			while(<=)
			while(sw == -1)
			{
				sw = 0;
				stopMultipleMotors(leftMotor, rightMotor);
			}
			if(vexRT[Btn7U] == 1)
			{
				forwardCTRL();
			}
			if(vexRT[Btn7D] == 1)
			{
				backwardsCTRL();
			}
			if(vexRT[Btn7R] == 1)
			{
				rightCTRL();
			}
			if(vexRT[Btn7L] == 1)
			{
				leftCTRL();
			}
			if(vexRT[Ch1] >= 70)
			{
				startTask(sonar);
			}
			if(vexRT[Ch1] <= -70)
			{
				stopTask(sonar);
			}
			if(vexRT[Btn5U] == 1 || vexRT[Btn5D] == 1)
			{
				armControl(armMotor, Btn5U, Btn5D, armspeed);
				wait1Msec(10);
				stopMotor(armMotor);
			}
			if(vexRT[Btn6U] == 1 || vexRT[Btn6D] == 1)
			{
				armControl(clawMotor, Btn6U, Btn6D, clawspeed);
				wait1Msec(10);
				stopMotor(clawMotor);
			}
			if(vexRT[Ch2] >= 70)
			{
				repeatUntil(vexRT[Ch2] <= -70)
				{
					goForward(2, 0);
					if(SensorValue[lineLeft] >= avoid)
					{
						correctionR();
					}
					if(SensorValue[lineRight] >= avoid)
					{
						correctionL();
					}
				}
				sw = -1;
			}
			if(vexRT[Btn8U] == 1)
			{
				goForward(3, 50);
				wait1Msec(30);
				swingLeft(1);
				goForward(3, 50);
				wait1Msec(30);
				swingRight(1);
				goForward(3, 50);
				wait1Msec(30);
				swingLeft(1);
				goForward(3, 50);
				wait1Msec(100);
				goLeft();
				goForward(3, 500);
				goRight();
			}
		}
	}
}
