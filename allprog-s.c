#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotent,      sensorPotentiometer)
#pragma config(Sensor, in2,    lineRight,      sensorLineFollower)
#pragma config(Sensor, in3,    lineCenter,     sensorLineFollower)
#pragma config(Sensor, in4,    lineLeft,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  frontTouch,     sensorTouch)
#pragma config(Sensor, dgtl6,  bumpTouch,      sensorTouch)
#pragma config(Sensor, dgtl7,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl12, led,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  rightIME,       sensorNone)
#pragma config(Sensor, I2C_2,  leftIME,        sensorNone)
#pragma config(Sensor, I2C_3,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl3)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//int variables. Declare before use!
int left = 36;
int right = 30;
int dist = 15;
int turn = 250;
int turnspeed = 70;
int sl = 600;
int sr = 605;
int leftc = 60;
int rightc = 60;
int avoid = 200;
int leftCorr = 100;
int rightCorr = 100;
int lc = 50;
int rc = 50;
int armspeed = 40;
int sw;
int t = 2000;

//void functions. Declare before use!
//Automatically turns left
void goLeft()
{
	resetSensor(leftEncoder);
	resetSensor(rightEncoder);
	setMotor(leftMotor, turnspeed);
	setMotor(rightMotor, -turnspeed);
	waitUntil(SensorValue[rightEncoder] >= turn && SensorValue[leftEncoder] <= -turn);
	stopMultipleMotors(leftMotor, rightMotor);
	wait(20, milliseconds);
}

//Automatically turns right
void goRight()
{
	resetSensor(leftEncoder);
	resetSensor(rightEncoder);
	setMotor(leftMotor, -turnspeed);
	setMotor(rightMotor, turnspeed);
	waitUntil(SensorValue[rightEncoder] <= -turn && SensorValue[leftEncoder] >= turn);
	stopMultipleMotors(leftMotor, rightMotor);
	wait(20, milliseconds);
}

/*Automatically goes forwards. !NOTE! this has a "switch" variable ('sw'). By
default, this value is set to 0 but can be changed by going: 'sw = 1;' when needed.
Please set back to 0 when done (sw = 0;).
*/
void goForward()
{
	setMotor(leftMotor, left);
	setMotor(rightMotor, right);
	if(sw == 1)
	{
		wait1Msec(t);
		stopMultipleMotors(leftMotor, rightMotor);
	}
	if(sw == 0)
	{
		waitUntil(SensorValue[sonarSensor] <= dist);
		stopMultipleMotors(leftMotor, rightMotor);
	}
}

void leftCTRL()
{
	setMotor(leftMotor, turnspeed);
	setMotor(rightMotor, -turnspeed);
	wait1Msec(20);
	if(vexRT[Btn7L] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}

void rightCTRL()
{
	setMotor(leftMotor, -turnspeed);
	setMotor(rightMotor, turnspeed);
	wait1Msec(20);
	if(vexRT[Btn7R] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}

void forwardCTRL()
{
	setMotor(rightMotor, rightc);
	setMotor(leftMotor, leftc);
	wait1Msec(20);
	if(vexRT[Btn7U] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}

void backwardsCTRL()
{
	setMotor(rightMotor, -rightc);
	setMotor(leftMotor, -leftc);
	wait1Msec(20);
	if(vexRT[Btn7D] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}

void swingLeft()
{
	resetSensor(leftEncoder);
	resetSensor(rightEncoder);
	setMotor(leftMotor, 0);
	setMotor(rightMotor, turnspeed);
	waitUntil(SensorValue[leftEncoder] >= sl);
	stopMultipleMotors(leftMotor, rightMotor);
	wait(20, milliseconds);
}

void swingRight()
{
	resetSensor(leftEncoder);
	resetSensor(rightEncoder);
	setMotor(leftMotor, turnspeed);
	setMotor(rightMotor, 0);
	waitUntil(SensorValue[rightEncoder] >= sr);
	stopMultipleMotors(leftMotor, rightMotor);
	wait(20, milliseconds);
}

void correctionL()
{
	setMotor(leftMotor, -lc);
	setMotor(rightMotor, rightCorr);
	wait(10, milliseconds);
}

void correctionR()
{
	setMotor(leftMotor, leftCorr);
	setMotor(rightMotor, -rc);
	wait(10, milliseconds);
}

void afo()
{
	setMotor(armMotor, armspeed);
	waitUntil(SensorValue[armPotent] <= 1250);
	stopMotor(armMotor);
}


task sonar()
{
	while(true)
		if(SensorValue[sonarSensor] <= dist)
	{
		stopAllMotors();
		}else{
		wait1Msec(10);
		if(vexRT[Btn8L] == 1)
		{
			stopTask(sonar);
		}
	}
}


task main()
{
	waitUntil(SensorValue[bumpTouch] == 1);
	{
		sw = 0;
		afo();
		repeat(forever)
		{
			if(vexRT[Btn8L] == 1)
			{
				startTask(sonar);
			}
			if(vexRT[Btn7U] == 1)
			{
				forwardCTRL();
			}
			if(vexRT[Btn7R] == 1)
			{
				rightCTRL();
			}
			if(vexRT[Btn7D] == 1)
			{
				backwardsCTRL();
			}
			if(vexRT[Btn7L] == 1)
			{
				leftCTRL();
			}
			if(vexRT[Btn5U] == 1 || vexRT[Btn5D] == 1)
			{
				armControl(clawMotor, Btn5U, Btn5D, 30);
				wait1Msec(100);
				stopMotor(clawMotor);
			}
			if(vexRT[Btn6U] == 1 || vexRT[Btn6D] == 1)
			{
				armControl(armMotor, Btn6U, Btn6D, 30);
				wait1Msec(100);
				stopMotor(armMotor);
			}
			if(vexRT[Btn8R] == 1)
			{
				sw = 1;
				goForward();
				sw = 0;
			}
			if(vexRT[Btn8U] == 1)
			{
				if(SensorValue[lineLeft] >= avoid)
				{
					correctionR();
				}
				if(SensorValue[lineRight] >= avoid)
				{
					correctionL();
				}
			}
		}
	}
}
