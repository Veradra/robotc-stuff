#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    centerLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  frontTouch,     sensorTouch)
#pragma config(Sensor, dgtl6,  bumpTouch,      sensorTouch)
#pragma config(Sensor, dgtl12, led,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  rightIME,       sensorNone)
#pragma config(Sensor, I2C_2,  leftIME,        sensorNone)
#pragma config(Sensor, I2C_3,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl3)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void resetencoders()
{
	resetSensor(rightEncoder);
	resetSensor(leftEncoder);
}

task main()
{
	//int mazeauto = <value>;
	int a = 31;
	int b = 40;
	repeat(forever)
	{
		//Arm Controls
		if (SensorValue[frontTouch] == 1 && vexRT[Btn5U] == 0)
		{
			//Raises the motor from being on the sensor
			moveMotor(armMotor, 250, milliseconds, 25);
			}else{
			armControl(armMotor, Btn6U, Btn6D, 25);
		}
		{
			armControl(clawMotor, Btn7L, Btn7R, 25);
		}
		if (vexRT[Btn7U] == 1)
		{
			//Line A
			resetSensor(leftEncoder);
			resetSensor(rightEncoder);
			setMultipleMotors(a, rightMotor, leftMotor);
			waitUntil(SensorValue[rightEncoder] >= 590 && SensorValue[leftEncoder] >= 590);
			stopAllMotors();
			wait(100, milliseconds);
			//Turn A
			resetSensor(leftEncoder);
			resetSensor(rightEncoder);
			setMotor(leftMotor, b);
			setMotor(rightMotor, -b);
			waitUntil(SensorValue[rightEncoder] >= 250 && SensorValue[leftEncoder] <= -250);
			stopAllMotors();
			wait(100, milliseconds);
			//Line B
			resetSensor(leftEncoder);
			resetSensor(rightEncoder);
			setMultipleMotors(a, rightMotor, leftMotor);
			waitUntil(SensorValue[rightEncoder] >= 850 && SensorValue[leftEncoder] >= 850);
			stopAllMotors();
			wait(100, milliseconds);
			//Turn B
			resetSensor(leftEncoder);
			resetSensor(rightEncoder);
			setMotor(leftMotor, -b);
			setMotor(rightMotor, b);
			waitUntil(SensorValue[rightEncoder] <= -275 && SensorValue[leftEncoder] >= 275);
			stopAllMotors();
			wait(100, milliseconds);
			//Line C
			resetSensor(leftEncoder);
			resetSensor(rightEncoder);
			setMultipleMotors(a, rightMotor, leftMotor);
			waitUntil(SensorValue[rightEncoder] >=  590 && SensorValue[leftEncoder] >= 590);
			stopAllMotors();
			wait(100, milliseconds);
			//Turn C
			resetSensor(leftEncoder);
			resetSensor(rightEncoder);
			setMotor(leftMotor, -b);
			setMotor(rightMotor, b);
			waitUntil(SensorValue[rightEncoder] <= -275 && SensorValue[leftEncoder] >= 275);
			stopAllMotors();
			wait(100, milliseconds);
			//Line D
			resetSensor(leftEncoder);
			resetSensor(rightEncoder);
			setMultipleMotors(a, rightMotor, leftMotor);
			waitUntil(SensorValue[rightEncoder] >= 400 && SensorValue[leftEncoder] >= 400);
			stopAllMotors();
			wait(100, milliseconds);
		}
		if(vexRT[Btn7D] == 1)
		{
			resetSensor(leftEncoder);
			resetSensor(rightEncoder);
		}
		if(vexRT[Btn5D] == 1)
		{
			moveMotor(armMotor, 800, milliseconds, 75);
			stopMotor(armMotor);
			repeat(forever)
			{
				if(SensorValue[bumpTouch] == 1)
				{
					//Go back
					setMultipleMotors(-a, leftMotor, rightMotor);
					waitUntil(SensorValue[rightEncoder] <= -150 && SensorValue[leftEncoder] <= -150);
					stopMultipleMotors(leftMotor, rightMotor);
					resetencoders();
					}else{
					//Forwards
					setMultipleMotors(a, rightMotor, leftMotor);
					waitUntil(SensorValue[bumpTouch] == 1);
					stopMultipleMotors(leftMotor,rightMotor);
					resetencoders();
				}
			}
		}
	}
}
