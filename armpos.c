#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotent,      sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  frontTouch,     sensorTouch)
#pragma config(Sensor, dgtl6,  bumpTouch,      sensorTouch)
#pragma config(Sensor, dgtl12, led,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  rightIME,       sensorNone)
#pragma config(Sensor, I2C_2,  leftIME,        sensorNone)
#pragma config(Sensor, I2C_3,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl3)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	//Defines some values for future ease of use
	int as = 30;
	int mvmnt = 50;
	int asd = -10;
	repeat(forever)
	{
		//Motor Control START
		while(vexRT[Btn7U] == 1)
		{
			//forwards
			setMultipleMotors(mvmnt, leftMotor, rightMotor);
			waitUntil(vexRT[Btn7U] == 0);
			stopMultipleMotors(leftMotor, rightMotor);
		}
		while(vexRT[Btn7D] == 1)
		{
			//backward
			setMultipleMotors(-mvmnt, leftMotor, rightMotor);
			waitUntil(vexRT[Btn7D] == 0);
			stopMultipleMotors(leftMotor, rightMotor);
		}
		while(vexRT[Btn7R] == 1)
		{
			//right(?)
			setMotor(leftMotor, -mvmnt);
			setMotor(rightMotor, mvmnt);
			waitUntil(vexRT[Btn7R] == 0);
			stopMultipleMotors(leftMotor, rightMotor);
		}
		while(vexRT[Btn7L] == 1)
		{
			//left(?)
			setMotor(leftMotor, mvmnt);
			setMotor(rightMotor, -mvmnt);
			waitUntil(vexRT[Btn7L] == 0);
			stopMultipleMotors(leftMotor, rightMotor);
		}
		//Movement controls END
		//Arm Control START
		if(vexRT[Btn8U] == 1)
		{
			//Makes arm go UP
			setMotor(armMotor, as);
			waitUntil(SensorValue[armPotent] <= 1250);
			stopMotor(armMotor);
		}
		if(vexRT[Btn8D] == 1)
		{
			//Makes the arm go DOWN to bottom
			setMotor(armMotor, asd);
			waitUntil(SensorValue[armPotent] >= 2500);
			stopMotor(armMotor);
			wait(200, milliseconds);
			setMotor(armMotor, as);
			waitUntil(SensorValue[armPotent] <= 2475);
			stopMotor(armMotor);
		}
		if(vexRT[Btn8L] == 1 && SensorValue[armPotent] >= 2000)
		{
			//Makes arm go UP from anything below half way
			setMotor(armMotor, as);
			waitUntil(SensorValue[armPotent] <= 2000);
			stopMotor(armMotor);
		}
		if(vexRT[Btn8L] == 1 && SensorValue[armPotent] <=2000)
		{
			//Makes arm go DOWN from anything above half way
			setMotor(armMotor, asd);
			waitUntil(SensorValue[armPotent] >= 2000);
			stopMotor(armMotor);
			setMotor(armMotor, as);
			wait(100, milliseconds);
			stopMotor(armMotor);
		}
		if(vexRT[Btn8R] == 1)
		{
			//Top > Wait > Half > Wait > Bottom > Stop
			//Going UP
			setMotor(armMotor, as);
			waitUntil(SensorValue[armPotent] <= 1250);
			stopMotor(armMotor);
			wait(2, seconds);
			//Going to the half point
			setMotor(armMotor, asd);
			waitUntil(SensorValue[armPotent] >= 2000);
			stopMotor(armMotor);
			wait(100, milliseconds);
			setMotor(armMotor, as);
			wait(100, milliseconds);
			stopMotor(armMotor);
			wait(2, seconds);
			//Going down
			setMotor(armMotor, asd);
			waitUntil(SensorValue[armPotent] >= 2525);
			stopMotor(armMotor);
			wait(100, milliseconds);
			setMotor(armMotor, as);
			waitUntil(SensorValue[armPotent] <= 2500);
			stopMotor(armMotor);
			//~fin~
		}
	}
}
