#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotent,      sensorPotentiometer)
#pragma config(Sensor, in2,    lineRight,      sensorLineFollower)
#pragma config(Sensor, in3,    lineCenter,     sensorLineFollower)
#pragma config(Sensor, in4,    lineLeft,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  frontTouch,     sensorTouch)
#pragma config(Sensor, dgtl6,  bumpTouch,      sensorTouch)
#pragma config(Sensor, dgtl7,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl12, led,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  rightIME,       sensorNone)
#pragma config(Sensor, I2C_2,  leftIME,        sensorNone)
#pragma config(Sensor, I2C_3,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl3)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//int variables. Declare before use!//
int left = 36;
int right = 30;
int dist = 15;
int turn = 250;
int turnspeed = 70;
int sl = 600;
int sr = 605;
int leftc = 60;
int rightc = 60;
int avoid = 200;
int leftCorr = 100;
int rightCorr = 100;
int lc = 25;
int rc = 25;
int armspeed = 40;
int clawspeed = 40;
int sw;
int t = 2000;

//void functions. Declare before use!
#include <of.c>
/*
Sonar task is here! This task will make sure you can toggle "crash mode"
aka, if you can run into a wall or not. Not much needs to be done with it.
*/

task sonar()
{
	while(true)
		if(SensorValue[sonarSensor] <= dist)
	{
		stopMultipleMotors(leftMotor, rightMotor);
		}else{
		wait1Msec(10);
	}
}

//Main task, has the bulk of the program in use.
task main()
{
	//We wait for the bumpTouch sensor to be pressed to start.
	waitUntil(SensorValue[bumpTouch] == 1 || vexRT[Ch4] == 127);
	{
		//Sets 'sw' to 0. Moves arm out of the way.
		sw = 0;
		afo();
		repeat(forever)
		{
			while(sw == -1)
			{
				sw = 0;
				stopMultipleMotors(leftMotor, rightMotor);
			}
			if(vexRT[Btn7U] == 1)
			{
				forwardCTRL();
			}
			if(vexRT[Btn7D] == 1)
			{
				backwardsCTRL();
			}
			if(vexRT[Btn7R] == 1)
			{
				rightCTRL();
			}
			if(vexRT[Btn7L] == 1)
			{
				leftCTRL();
			}
			if(vexRT[Ch1] >= 70)
			{
				startTask(sonar);
			}
			if(vexRT[Ch1] <= -70)
			{
				stopTask(sonar);
			}
			if(vexRT[Btn5U] == 1 || vexRT[Btn5D] == 1)
			{
				armControl(armMotor, Btn5U, Btn5D, armspeed);
				wait1Msec(10);
				stopMotor(armMotor);
			}
			if(vexRT[Btn6U] == 1 || vexRT[Btn6D] == 1)
			{
				armControl(clawMotor, Btn6U, Btn6D, clawspeed);
				wait1Msec(10);
				stopMotor(clawMotor);
			}
			if(vexRT[Ch2] >= 70)
			{
				repeatUntil(vexRT[Ch2] <= -70)
				{
					goForward(2, 0);
					if(SensorValue[lineLeft] >= avoid)
					{
						correctionR();
					}
					if(SensorValue[lineRight] >= avoid)
					{
						correctionL();
					}
				}
				sw = -1;
			}
			if(vexRT[Btn8U] == 1)
			{
				goForward(3, 50);
				wait1Msec(30);
				swingLeft(1);
				goForward(3, 50);
				wait1Msec(30);
				swingRight(1);
				goForward(3, 50);
				wait1Msec(30);
				swingLeft(1);
				goForward(3, 50);
				wait1Msec(100);
				goLeft();
				goForward(3, 500);
				goRight();
			}
		}
	}
}
