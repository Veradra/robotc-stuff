#pragma config(Sensor, in8,    liftStop,       sensorReflection)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl12, led,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  rightIME,       sensorNone)
#pragma config(Sensor, I2C_2,  leftIME,        sensorNone)
#pragma config(Sensor, I2C_3,  armIME,         sensorNone)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl3)
#pragma config(Motor,  port6,           liftMotor,     tmotorVex393_MC29, openLoop, encoderPort, dgtl5)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//There are too many comments.

//int
int speed = 127;
int leftc = 60;
int rightc = 60;
int turnspeed = 70;
int safetydis;
int sdm;
int sdm2;

//void
//Allows us to lift the lift up.
void liftup()
{
	if(vexRT[Btn5U] == 1)
	{
		setMotor(liftMotor, speed);
		wait1Msec(10);
		if(vexRT[Btn5U] == 0)
		{
			stopMotor(liftMotor);
		}
	}
}

//Allows us to lift the lift down.
void liftdown()
{
	if(vexRT[Btn5D] == 1)
	{
		setMotor(liftMotor, -speed);
		wait1Msec(10);
		if(vexRT[Btn5D] == 0)
		{
			setMotor(liftMotor, speed);
			wait1Msec(30);
			stopMotor(liftMotor);
		}
	}
}

//Allows for left point turns.
void leftCTRL()
{
	setMotor(leftMotor, turnspeed);
	setMotor(rightMotor, -turnspeed);
	wait1Msec(10);
	if(vexRT[Btn7L] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}
//Allows for manual right point turns.
void rightCTRL()
{
	setMotor(leftMotor, -turnspeed);
	setMotor(rightMotor, turnspeed);
	wait1Msec(10);
	if(vexRT[Btn7R] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}
//Allows for manual forwards.
void forwardCTRL()
{
	setMotor(rightMotor, rightc);
	setMotor(leftMotor, leftc);
	wait1Msec(10);
	if(vexRT[Btn7U] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}
//Allows for manual backwards.
void backwardsCTRL()
{
	setMotor(rightMotor, -rightc);
	setMotor(leftMotor, -leftc);
	wait1Msec(10);
	if(vexRT[Btn7D] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}

/*Thought I'd mention this, but we aren't using the joystick because despite my best
efforts, I couldn't get it to work. I gave up and decided "Ah fk it, digital all the
way I guess" and are using the face buttons, so no variable speeds :(. Might try again
and get it to work, but that'll be a pain to get working again.*/

//task(s)

/*math or something. We're taking the button presses and dividing it by the CPU's
fequency (10MHz, 10,000 Hz) to get how many seconds we are pressing the button for.
Please note however, this task is more or less unused and exists soley as a "proof
of concept." There is a way to use this, however! You have to hold 8U down for at
least 1 second for it to work, which is also the reason it isn't used. See the part
of the code commented out, under the header "//SEE". It's near the bottom of the
code, by the way. All you need to do is uncomment the sdm2 part, and comment out the
safetydis part to avoid conflicts*/
task mth()
{
	while(true)
	{
		/*We "copy" the value of safetydis to sdm, so we are not doing anything destructive
		to safety dis, in the event that we need the raw value.*/
		sdm = safetydis;
		wait1Msec(100);
		/*We devide sdm by 10,000 to get approximately how many seconds we have pressed the
		button for, then "copy" it to sdm2 for future use.*/
		sdm2 = sdm/10000;
	}
}

//Emergency lift stops.
task liftstops()
{
	while(true)
	{
		/*We wait for either the lift encoder (liftEnc) to detect that the lift has gotten too far
		up, or for the light sensor (liftStop) to detect that we are near the bottom.*/
		if(SensorValue[liftStop] >= 500 || SensorValue[liftEnc] >= 825)
		{
			//Stops the motor regardless of state.
			stopMotor(liftMotor);
			//If the lifttSop is tripped.
			if(SensorValue[liftStop] >= 500)
			{
				setMotor(liftMotor, speed);
				wait1Msec(15);
				stopMotor(liftMotor);
				//If this isn't met, to prevent the task from hogging CPU time, we tell it to wait
				//before trying again.
				}else{
				wait1Msec(10);
			}
			//If liftEnc is tripped.
			if(SensorValue[liftEnc] >= 825)
			{
				setMotor(liftMotor, -speed);
				wait1Msec(15);
				stopMotor(liftMotor);
				//If this isn't met, to prevent the task from hogging CPU time, we tell it to wait
				//before trying again.
				}else{
				wait1Msec(10);
			}
		}
		//Just turn off all the motors, when the Ch2 joystick has been sufficently pressed.
		//Use when "things" go south.
		if(vexRT[Ch2] >= 100)
		{
			stopAllMotors();
		}
	}
}

//main task
task main()
{
	//Start the mth task
	startTask(mth);
	/*We do the following to calibration, and to have a contstant 0 value for liftEnc
	for ease of programming.*/
	//Send the lift motor down
	setMotor(liftMotor, -speed);
	/*Wait until liftStop is tripped. We use this as it's analog, and thus keeps a value
	between power states.*/
	waitUntil(SensorValue[liftStop] >= 500);
	//Stop the motor, we've reached our goal.
	stopMotor(liftMotor);
	//Set liftEnc to 0 here.
	resetSensor(liftEnc);
	//Start the safety "liftstops" task.
	startTask(liftstops);
	//loop
	repeat(forever)
	{
		/*The following are all looking for certain actions, like us pressing a button, which
		triggers a certain void function to run.*/
		if(vexRT[Btn5D] == 1)
		{
			liftdown();
		}
		if(vexRT[Btn5U] == 1)
		{
			liftup();
		}
		if(vexRT[Btn7U] == 1)
		{
			forwardCTRL();
		}
		if(vexRT[Btn7D] == 1)
		{
			backwardsCTRL();
		}
		if(vexRT[Btn7R] == 1)
		{
			rightCTRL();
		}
		if(vexRT[Btn7L] == 1)
		{
			leftCTRL();
		}
		//Button to disable the "safety". Only reason to use this is when adding something onto
		//the lift, and going all the way UP.
		if(vexRT[Btn8U] == 1)
		{
			stopTask(liftstops);
			//We add 1 to safety dis as long as we are pressng 8U. This is added 10,000 times per second,
			//which is the clockspeed for the controller/VEXnet wireless... thing.
			++safetydis;
		}
		//Allows us to re-enable the safety, as long as we have pressed 8U for at least some time, approx
		//0.01 seconds.
		//SEE
		if(vexRT[Btn8D] == 1 && safetydis >= 100 /*sdm2 >= 1*/)
		{
			startTask(liftstops);
			//Also we reset safetydis so we don't start the task again by accident. Don't set sdm or sdm2
			//to 0 individually, as next CPU cycle they'll be set to 0 anyways.
			safetydis = 0;
		}
	}
}
//There's nothing here.
