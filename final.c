#pragma config(Sensor, in8,    liftStop,       sensorReflection)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  liftGo,         sensorTouch)
#pragma config(Sensor, dgtl12, led,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  rightIME,       sensorNone)
#pragma config(Sensor, I2C_2,  leftIME,        sensorNone)
#pragma config(Sensor, I2C_3,  armIME,         sensorNone)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl3)
#pragma config(Motor,  port6,           liftMotor,     tmotorVex393_MC29, openLoop, encoderPort, dgtl5)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//See final-expcomments.c for this with significantly more comments + unused stuff.
//By the way, we only have 15K of RAM to play with.

//int values.
int speed = 127;
int leftc = 60;
int rightc = 60;
int turnspeed = 70;
int safetydis;
int sdm;
int sdm2;
int spdmul = 1;
int rnd;
//Void starts here
//Raise lift
void liftup()
{
	if(vexRT[Btn5U] == 1)
	{
		setMotor(liftMotor, speed);
		wait1Msec(10);
		if(vexRT[Btn5U] == 0)
		{
			stopMotor(liftMotor);
		}
	}
}
//Lower lift
void liftdown()
{
	if(vexRT[Btn5D] == 1)
	{
		setMotor(liftMotor, -speed);
		wait1Msec(10);
		if(vexRT[Btn5D] == 0)
		{
			setMotor(liftMotor, speed);
			wait1Msec(30);
			stopMotor(liftMotor);
		}
	}
}
//Left point turn
void leftCTRL()
{
	setMotor(leftMotor, turnspeed);
	setMotor(rightMotor, -turnspeed);
	wait1Msec(10);
	if(vexRT[Btn7L] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}
//Right point turn
void rightCTRL()
{
	setMotor(leftMotor, -turnspeed);
	setMotor(rightMotor, turnspeed);
	wait1Msec(10);
	if(vexRT[Btn7R] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}
//Forward control
void forwardCTRL()
{
	setMotor(rightMotor, rightc * spdmul);
	setMotor(leftMotor, leftc * spdmul);
	wait1Msec(10);
	if(vexRT[Btn7U] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}
//Backwards control
void backwardsCTRL()
{
	setMotor(rightMotor, -rightc * spdmul);
	setMotor(leftMotor, -leftc * spdmul);
	wait1Msec(10);
	if(vexRT[Btn7D] == 0)
	{
		stopMultipleMotors(leftMotor, rightMotor);
	}
}
//Automatic part of program, called later.
void autoctrl()
{
	waitUntil(vexRT[Btn6D] == 1);
	setMotor(liftMotor, -speed);
	waitUntil(SensorValue[liftStop] >= 500);
	stopMotor(liftMotor);
	waitUntil(SensorValue[liftGo] == 1);
	setMotor(liftMotor, speed);
	waitUntil(SensorValue[liftEnc] >= 800);
	stopMotor(liftMotor);
	setMotor(leftMotor, leftc);
	setMotor(rightMotor, rightc);
	wait1Msec(2000);
	stopMultipleMotors(leftMotor, rightMotor);
	setMotor(liftMotor, -speed);
	waitUntil(SensorValue[liftStop] >= 500);
	stopMotor(liftMotor);
}
//Tasks begin here
//Math & LED blinker
task mth()
{
	while(true)
	{
		//See if rnd is a multiple of 8. (Modulo)
		if(rnd % 8 == 0)
		{
			//Blink LED if it is
			turnLEDOn(led);
			wait1Msec(10);
			turnLEDOff(led);
			//Get new rnd value
			rnd = rand();
		}else{
			//Just get new rnd if it isn't
			rnd = rand();
			wait1Msec(10);
		}
		//Safety-related math. Unused.
		sdm = safetydis;
		wait1Msec(100);
		sdm2 = sdm/10000;
	}
}

//Safety
task liftstops()
{
	//Loop
	while(true)
	{
		//Check the safety
		if(SensorValue[liftStop] >= 500 || SensorValue[liftEnc] >= 825)
		{
			//If either is tripped we're stopping the motor
			stopMotor(liftMotor);
			//See which one, then act upon it
			if(SensorValue[liftStop] >= 500)
			{
				setMotor(liftMotor, speed);
				wait1Msec(15);
				stopMotor(liftMotor);
				}else{
				wait1Msec(10);
			}
			if(SensorValue[liftEnc] >= 825)
			{
				setMotor(liftMotor, -speed);
				wait1Msec(15);
				stopMotor(liftMotor);
				}else{
				wait1Msec(10);
			}
		}
		//Stop motors if Ch2 >= 100
		if(vexRT[Ch2] >= 100)
		{
			stopAllMotors();
		}
	}
}

//Main
task main()
{
	//Generate seed
	srand(nSysTime);
	//Start math & LED blinker
	startTask(mth);
	//Recalibrate
	setMotor(liftMotor, -speed);
	waitUntil(SensorValue[liftStop] >= 500);
	stopMotor(liftMotor);
	resetSensor(liftEnc);
	//Start the safety
	startTask(liftstops);
	repeat(forever)
	{
		//Lift controls
		if(vexRT[Btn5D] == 1)
		{
			liftdown();
		}
		if(vexRT[Btn5U] == 1)
		{
			liftup();
		}
		//Movement controls
		if(vexRT[Btn7U] == 1)
		{
			forwardCTRL();
		}
		if(vexRT[Btn7D] == 1)
		{
			backwardsCTRL();
		}
		if(vexRT[Btn7R] == 1)
		{
			rightCTRL();
		}
		if(vexRT[Btn7L] == 1)
		{
			leftCTRL();
		}
		//2x speed
		if(vexRT[Btn8R] == 1)
		{
			spdmul = 2;
		}
		//Set back to normal
		if(vexRT[Btn8L] == 1)
		{
			spdmul = 1;
		}
		//Start auto
		if(vexRT[Btn6U] == 1)
		{
			stopTask(liftstops);
			autoctrl();
			startTask(liftstops);
		}
		//Enable/disable safety
		if(vexRT[Btn8U] == 1)
		{
			stopTask(liftstops);
			++safetydis;
		}
		if(vexRT[Btn8D] == 1 && safetydis >= 100)
		{
			startTask(liftstops);
			safetydis = 0;
		}
	}
}
//There's nothing here.